## T1 score

### 30 pts

暴力枚举，复杂度 $O(n^3)$。即枚举以 $i$ 开头，以 $j$ 结尾的区间，并 $O(n)$ 求和

### 60 pts

预处理出前缀和数组 $sum[i]$，同样还是枚举区间，求和的复杂度降到了 $O(1)$，总的复杂度为 $O(n^2)$

### 100 pts

考虑每一个数会被多少个区间包括。

例如：$3$ 个数 $[1,2,3]$。包括 $1$ 的区间有 $[1,1], [1,2], [1,3]$，包括 $2$ 的区间有 $[1,2],[1,3],[2,2],[2,3]$ 共四个。

对于每个位置 $i$，包含 $A[i]$ 的区间共有 $i*(n-i+1)$ 个，所以 $A[i]$ 被统计了 $i*(n-i+1)$ 次。

用这个方法计算，时间复杂度为 $O(n)$。

## T2 travel

### 40 pts

对于 $40\%$ 的数据，有 $N \leq 1000$。

暴力一个一个点判断。

### 100 pts

对于 $100\%$ 的数据，有 $N \leq 200000$。

暴力不再适用。

首先注意到题目中有可能出现环的情况，因此我们先用 拓扑排序 找出图上的环，并进行处理。

随后再找出链，并在链上进行简单递推即可。

## T3 output

利用快读区分出数字和字母，模拟 for 循环可以得到一部分分数。

最后一层循环可以利用等差数列求和直接展开。

## T4 string

### 30 pts

对于30%的数据，有 $m = 0$。

如何统计一个给定串不同的子序列个数？

**DP**

- $last[i]$ 表示字符 $s[i]$ 上一次出现的位置
- $f[i]$ 表示以第 $i$ 位结尾的新出现的不同子序列个数

考虑加入一个新的 $i$，那么所有以第 $x$ 位（$last[i] \leq x \leq i - 1$）结尾的新出现的子序列，都可以加上一个 $i$，得到一个新的子序列。

如何证明 $x(1 \leq x \leq last[i] - 1)$ 接上 $s[i]$ 不会形成新的子序列？

**反证法**

- 如果以 $last[i] - 1$ 之前的某个位置为结尾的子序列接上第 $i$ 位，会产生一个新的子序列，那么之前的子序列直接加上 $last[i]$ 也可以产生这个新的子序列。
- 与这个子序列在 $i$ 第一次出现矛盾。

于是我们得到方程 $f[i] = \sum_{j=last[i]}^{i-1} f[j]$。

用树状数组或前缀和优化即可。

### 100 pts

对于100%的数据，有 $0 \leq n, m \leq 1000000, 1 \leq k \leq 26$。

记 $g[i]$ 为 $f[i]$ 的前缀和 $f[i] = g[i - 1] - g[last[i] - 1]$。

每次贪心选取使 $last[i] - 1$ 最小即可。

时间复杂度 $O((n + m) \times 26)$，空间复杂度 $O(n)$。

很容易发现 $f[i]$ 与 $f[last[i]]$ 有关，所有变量都可开成临时变量。内存可以优化为 $O(k)$。
